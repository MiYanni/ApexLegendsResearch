// todo(dw): re-add rodeo stats
// todo(dw): player.SetRodeoAllowed( .. )
// todo(dw): player.SetIsValidRodeoTarget( .. )
// todo(dw): player.GetTitanSoulBeingRodeod()
// todo(dw): vscripts/rodeo_new/ -> vscript/rodeo/


global function ShRodeo_Init

global function RodeoState_GetIsPlayerRodeoing
global function RodeoState_GetIsPlayerRodeoingVehicle
global function RodeoState_GetPlayerCurrentRodeoVehicle
global function RodeoState_GetPlayersRodeingVehicle
global function RodeoState_GetIsVehicleBeingRodeoed
global function RodeoState_GetRiderInSpot
global function RodeoState_CheckSpotsAreAvailable
global function RodeoState_IsRiderBusy
global function RodeoState_GetRiderCurrentSpot
global function RodeoState_GetRiderCurrentTransition
global function RodeoState_GetRiderTimeSinceRodeo
global function RodeoState_IsRiderAllowedToRodeo

global function Rodeo_RegisterVehicle
global function Rodeo_IsRodeoVehicle
#if SERVER
global function Rodeo_TriggerRiderRodeoEnd
global function Rodeo_TriggerVehicleAllRodeosEnd
global function Rodeo_ThrowRiderOff
global function Rodeo_TriggerTransitionAndWait
global function Rodeo_RiderAllow
global function Rodeo_RiderDisallow
#endif

global function RodeoUtil_GetVehicleRodeoStateEnt
global function RodeoUtil_GetVehicleEntFromStateEnt

global function RodeoVehicleFlavor_AddSpot
global function RodeoVehicleFlavor_AddTransition

global function AddCallback_CanRiderRodeoVehicle
global function AddCallback_OnRodeoStarting
global function AddCallback_OnRodeoEnded

global function CodeCallback_IsValidRodeoTarget
global function CodeCallback_CanPlayerRodeo
global function CodeCallback_OnRodeoAttach
global function CodeCallback_TitanRiderEntVarChanged
#if SERVER
global function CodeCallback_StartRodeo
global function CodeCallback_ForceEndRodeo
#endif
#if CLIENT
global function ClientCodeCallback_TitanRodeoedUpdated
global function ClientCodeCallback_RodeoHitTimeChanged
#endif

// A "rodeo-vehicle" is something that can be ridden by a "rodeo-rider" -- like a titan or a super-spectre.
// A "rodeo-rider" is something that can rodeo a "rodeo-vehicle" -- a player or, perhaps later, an AI unit.
//
// A "flavor" is the idea of a situation (like "kind", "type" or "class" but not quite the same).
// A "vehicle flavor" tells us what to do for a particular class of rodeo vehicle -- like a titan, a super-spectre, or a car.
// A "spot flavor" tells us what to do for a particular rodeo-position on a particular class of vehicle -- like "left shoulder" or "right shoulder".
// A "transition flavor" tells us how we can:
//	- Move to a spot on the vehicle from the world (attaching).
//  - Move from one spot on the vehicle to different spot on the same vehicle
//	- Move from a spot on the vehicle to the world (detaching).

// RodeoVehicleState tells us:
//	- Which rodeo-riders are currently riding (an array of RodeoRiderState).
//	- Which spots are currently reserved (a table mapping RodeoSpotFlavor.index to RodeoRiderState).
//
// RodeoRiderState tells us:
//	- Who the rider is (entity).
//	- Which vehicle they are riding ("vehicle state entity").
//	- What "spot flavor" they are currently in.
//  - What "transition flavor" they are currently executing, if any.

// RodeoVehicleFlavor tells us:
//	- Which function to execute (threaded) for this flavor of vehicle (e.g.: titans behave differently to super-spectres).
//	- Which spots the rider can use (an array of RodeoSpotFlavor).
//	- How the rider can move between spots (an array of RodeoTransitionFlavor).
//  - How a rider should attach the titan from a given attach direction (a map of eRodeoSpotAttachMode to RodeoTransitionFlavor).

// todo(dw): describe RodeoSpotFlavor and RodeoTransitionFlavor

// COMPLICATION:
//	Vehicles have a "vehicle state entity."
//	Examples:
//		For a super-spectre, this is the super-spectre itself (vehicleEnt == vehicleStateEnt).
//		For a car, this is the car itself (vehicleEnt == vehicleStateEnt).
//		For a titan, this is their soul (vehicleEnt != vehicleStateEnt).

//////////////////////
//////////////////////
//// Global Types ////
//////////////////////
//////////////////////

/* None */
global const int RODEO_SENTINEL_TRANSITION_NONE = -1
global const int RODEO_SENTINEL_INVALID_SPOT = -99
global const int RODEO_SENTINEL_BEGIN_SPOT_ATTACH = -1
global const int RODEO_SENTINEL_END_SPOT_DETACH = -1

global enum eCanRiderRodeoVehicleResult
{
	USE_DEFAULT_BEHAVIOUR,
	ALLOW,
	DISALLOW,
}

///////////////
///////////////
//// Types ////
///////////////
///////////////
global struct RodeoSpotFlavor
{
	int    index = -1
	string thirdPersonIdleAnim = ""
	string firstPersonIdleAnim = ""
	string attachPoint = "ref"
	//bool   useAttachAngles = true //true: animate relative to attach tag angles. false: use player angles, like on drones where direction is irrelevant
	bool   viewConeEnabled = true
	float  viewConeYawMin = 0
	float  viewConeYawMax = 0
	float  viewConePitchMin = 0
	float  viewConePitchMax = 0
	bool   disableWeapons = false

	// todo(dw): do we need rodeo idle sounds?

	void functionref( entity rider, entity vehicle ) onRiderArrivedAtRodeoSpotFunc

	bool idleIsError = false
}

global struct RodeoTransitionFlavor
{
	int index = -1

	int        beginSpotIndex = RODEO_SENTINEL_BEGIN_SPOT_ATTACH // must be RODEO_SENTINEL_BEGIN_SPOT_ATTACH (-1) if this is an attach transition
	array<int> transientSpotIndexList // additional spots to reserve (can be empty) (endSpot is automatically reserved)
	int        endSpotIndex = RODEO_SENTINEL_END_SPOT_DETACH // ust be RODEO_SENTINEL_END_SPOT_DETACH (-1) if this is a detach transition

	bool                                                     doBasicAnim = true
	void functionref( entity rider, entity vehicleStateEnt ) execFunc // if null, DoTransitionBasicAnim will be used instead

	// the following cannot be null for attach transitions
	string ornull attachment
	//bool          useAttachAngles = true //true: animate relative to attach tag angles. false: use player angles, like on drones where direction is irrelevant
	string ornull thirdPersonAnim
	string ornull firstPersonAnim
	string ornull worldSound
	string ornull cockpitSound
}

global struct RodeoVehicleFlavor
{
	bool functionref( entity rider, entity vehicle ) isValidRodeoTarget
	int functionref( entity rider, entity vehicle )  getAttachTransition // should return RODEO_TRANSITION_NONE (-1) if not rodeoable
	void functionref( entity rider, entity vehicle ) onRodeoStartingFunc
	#if SERVER
		void functionref( entity rider, entity vehicle, int beginSpotIndex, int endSpotIndex, int transitionIndex ) onRodeoTransitionStartingFunc
		//void functionref( entity rider, entity vehicle, int beginSpotIndex, int endSpotIndex ) onRodeoTransitionEndingFunc
		void functionref( entity rider, entity vehicle, int spotIndex )                                             onRodeoRiderIdlesInSpotFunc
	#endif
	void functionref( entity rider, entity vehicle ) onRodeoFinishingFunc

	table<int, RodeoSpotFlavor>       spotMap
	table<int, RodeoTransitionFlavor> transitionMap
	int                               jumpOffKey = IN_JUMP
}

struct RodeoVehicleState
{
	RodeoVehicleFlavor& flavor
	entity              stateEnt
}

struct RodeoRiderState
{
	entity rider
	entity vehicleStateEnt = null // if this is null, this rider is not currently rodeoing
	float  prevRodeoTime = -9999.0

	#if SERVER
		int  currentSpotIndex = RODEO_SENTINEL_INVALID_SPOT // The primary spot we're using. If transitioning, this is our destination
		int  currentTransitionIndex = RODEO_SENTINEL_TRANSITION_NONE
		bool playerHadBatteryAtStartOfRodeo
		bool playerWasEjecting
		bool areWeaponsDisabled = false

		string lastTransitionCockpitSoundPlayed = ""
		string lastTransitionWorldSoundPlayed = ""

		float ornull timePressedUseToDetach = null

		int disallowRodeoStackCount = 0
	#endif
}


//////////////////////
//////////////////////
//// Global State ////
//////////////////////
//////////////////////
struct
{
	bool PROTO_IsRodeoEvenUsed = false

	array<int functionref( entity rider, entity vehicle )>  canRiderRodeoVehicleCallbacks
	array<void functionref( entity rider, entity vehicle )> onRodeoStartingCallbacks
	array<void functionref( entity rider, entity vehicle )> onRodeoEndedCallbacks

	table<entity, RodeoVehicleState>                        vehicleStateMap
	table<entity, RodeoRiderState>                          riderStateMap
} file


////////////////////////
////////////////////////
//// Initialization ////
////////////////////////
////////////////////////
void function ShRodeo_Init()
{
	RegisterSignal( "RodeoStarting" )
	#if SERVER
		RegisterSignal( "RodeoClimbComplete" )
		RegisterSignal( "RodeoTriggerGracefulDetach" )
		RegisterSignal( "RodeoTriggerInstantDetach" )
		RegisterSignal( "RodeoTransitionStarting" )
		RegisterSignal( "RodeoTransitionEnded" )
		RegisterSignal( "RodeoEnding" ) // wait on this if you want to respond as early as possible
	#endif
	RegisterSignal( "RodeoEnded" ) // wait on this if you want to know when the rodeo is completely finished

	RegisterSignal( "RodeoRiderAttached" )
	RegisterSignal( "RodeoRiderDetached" )

	RegisterSignal( "PlayerStopsRequestingRodeo" )

	#if SERVER
		AddCallback_OnClientConnected( OnPlayerCreated )
		//AddCallback_OnClientDisconnected( OnPlayerDestroyed )
		AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	#endif

	#if CLIENT
		AddCreateCallback( "player", OnPlayerCreated )
		AddDestroyCallback( "player", OnPlayerDestroyed )
		AddCallback_OnPlayerLifeStateChanged( OnPlayerLifestateChanged )
	#endif

	ShTitanRodeo_Init()
	ShReaperRodeo_Init()
	ShCarRodeo_Init()
}


//////////////////////////
//////////////////////////
//// Global Functions ////
//////////////////////////
//////////////////////////
void function Rodeo_RegisterVehicle( entity vehicle, RodeoVehicleFlavor flavor )
{
	RodeoVehicleState vehicleState
	vehicleState.stateEnt = RodeoUtil_GetVehicleRodeoStateEnt( vehicle )
	vehicleState.flavor = flavor

	Assert( !(vehicleState.stateEnt in file.vehicleStateMap), "Vehicle has already been registered: " + vehicle )

	file.vehicleStateMap[ vehicleState.stateEnt ] <- vehicleState

	#if SERVER
		vehicle.SetNumRodeoSlots( vehicleState.flavor.spotMap.len() )
	#endif

	AddEntityDestroyedCallback( vehicleState.stateEnt, OnRodeoVehicleStateEntDestroyed )

	file.PROTO_IsRodeoEvenUsed = true
	#if CLIENT
		OnPlayerLifestateChanged( GetLocalClientPlayer(), LIFE_INVALID, LIFE_ALIVE )
	#endif
}


bool function Rodeo_IsRodeoVehicle( entity vehicle )
{
	return (RodeoUtil_GetVehicleRodeoStateEnt( vehicle ) in file.vehicleStateMap)
}


bool function RodeoState_GetIsPlayerRodeoing( entity player )
{
	return GetRiderCurrentVehicle( player ) != null
}


bool function RodeoState_GetIsPlayerRodeoingVehicle( entity player, entity vehicle )
{
	return GetRiderCurrentVehicle( player ) == vehicle
}


entity function RodeoState_GetPlayerCurrentRodeoVehicle( entity player )
{
	return GetRiderCurrentVehicle( player )
}


array<entity> function RodeoState_GetPlayersRodeingVehicle( entity vehicle, int allegiance = eAllegiance.IRRELEVANT )
{
	array<entity> riderList = []
	for ( int spotIndex = 0; spotIndex < vehicle.GetNumRodeoSlots(); spotIndex++ )
	{
		entity rider = vehicle.GetRodeoRider( spotIndex )
		if ( IsValid( rider ) && AllegianceCheck( allegiance, vehicle, rider ) )
			riderList.append( rider )
	}
	return riderList
}


bool function RodeoState_GetIsVehicleBeingRodeoed( entity vehicle, int allegiance = eAllegiance.IRRELEVANT )
{
	for ( int spotIndex = 0; spotIndex < vehicle.GetNumRodeoSlots(); spotIndex++ )
	{
		entity rider = vehicle.GetRodeoRider( spotIndex )
		if ( IsValid( rider ) && AllegianceCheck( allegiance, vehicle, rider ) )
			return true
	}
	return false
}


entity function RodeoState_GetRiderInSpot( entity vehicle, int spotIndex )
{
	return vehicle.GetRodeoRider( spotIndex )
}


bool function RodeoState_CheckSpotsAreAvailable( entity vehicle, ... )
{
	for ( int argI = 0; argI < vargc; argI++ )
	{
		int spotIndex = expect int( vargv[argI] )
		if ( vehicle.GetRodeoRider( spotIndex ) != null )
		{
			return false
		}
	}
	return true
}


bool function RodeoState_IsRiderBusy( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )
	Assert( riderState.vehicleStateEnt != null )
	#if SERVER
		return (riderState.currentTransitionIndex != RODEO_SENTINEL_TRANSITION_NONE)
	#else
		Assert( false, "nyi" )
		unreachable
	#endif
}


int function RodeoState_GetRiderCurrentSpot( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )
	Assert( riderState.vehicleStateEnt != null )
	#if SERVER
		return riderState.currentSpotIndex
	#else
		Assert( false, "nyi" )
		unreachable
	#endif
}


int function RodeoState_GetRiderCurrentTransition( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )
	Assert( riderState.vehicleStateEnt != null )
	#if SERVER
		return riderState.currentTransitionIndex
	#else
		Assert( false, "nyi" )
		unreachable
	#endif
}


float function RodeoState_GetRiderTimeSinceRodeo( entity rider )
{
	if ( RodeoState_GetIsPlayerRodeoing( rider ) )
		return 0.0

	RodeoRiderState riderState = GetRodeoRiderState( rider )
	return Time() - riderState.prevRodeoTime
}


bool function RodeoState_IsRiderAllowedToRodeo( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )

	#if SERVER
		return (riderState.disallowRodeoStackCount == 0)
	#else
		return true // todo(dw): implement RodeoState_IsRiderAllowedToRodeo for CLIENT
	#endif
}


entity function RodeoUtil_GetVehicleRodeoStateEnt( entity vehicle )
{
	return vehicle.IsTitan() ? vehicle.GetTitanSoul() : vehicle
}


entity function RodeoUtil_GetVehicleEntFromStateEnt( entity vehicleStateEnt )
{
	return IsSoul( vehicleStateEnt ) ? vehicleStateEnt.GetTitan() : vehicleStateEnt
}


#if SERVER
void function Rodeo_TriggerRiderRodeoEnd( entity rider, bool instant = false )
{
	//Assert( rider.vehicleStateEnt != null ) // it's OK if we're not rodeoing

	rider.Signal( instant ? "RodeoTriggerInstantDetach" : "RodeoTriggerGracefulDetach" )
}
#endif

#if SERVER
void function Rodeo_TriggerVehicleAllRodeosEnd( entity vehicle, bool instant = false )
{
	foreach( entity rider in RodeoState_GetPlayersRodeingVehicle( vehicle ) )
	{
		Rodeo_TriggerRiderRodeoEnd( rider, instant )
	}
}
#endif

#if SERVER
void function Rodeo_ThrowRiderOff( entity rider, entity vehicle, vector vel, bool adjustAirControl = true )
{
	//rider.p.rodeoShouldAdjustJumpOffVelocity = false

	Rodeo_TriggerRiderRodeoEnd( rider, true )

	//rider.WaitSignal( "RodeoEnded" ) // todo(dw): find a way to detect if we actually ended the rodeo with this call

	//rider.SetOrigin( rider.GetOrigin() + <0,0,100> )

	rider.SetVelocity( vel )
}
#endif

#if SERVER
void function Rodeo_TriggerTransitionAndWait( entity rider, int transitionIndex )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )
	Assert( riderState.vehicleStateEnt != null )
	RodeoVehicleState vehicleState = GetRodeoVehicleState( riderState.vehicleStateEnt )
	Assert( !RodeoState_IsRiderBusy( rider ) )

	#if SERVER // todo(dw): predict shift & activity transition
		InitRiderTransition( riderState, vehicleState, transitionIndex )
		waitthread DoRiderTransition( riderState, vehicleState )
	#else
		Assert( false, "nyi" )
		unreachable
	#endif
}
#endif

#if SERVER
void function Rodeo_RiderAllow( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )
	riderState.disallowRodeoStackCount--

	Assert( riderState.disallowRodeoStackCount >= 0, "Called Rodeo_RiderAllow but rodeo wasn't disallowed" )

	//if ( riderState.disallowRodeoStackCount == 0 )
	//	Code_Rodeo_RiderAllow( rider )
}
#endif

#if SERVER
void function Rodeo_RiderDisallow( entity rider )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )

	//if ( riderState.disallowRodeoStackCount == 0 )
	//	Code_Rodeo_RiderDisallow( rider )

	riderState.disallowRodeoStackCount++
}
#endif

void function AddCallback_CanRiderRodeoVehicle( int functionref( entity rider, entity vehicle ) callbackFunc )
{
	file.canRiderRodeoVehicleCallbacks.append( callbackFunc )
}


void function AddCallback_OnRodeoStarting( void functionref( entity rider, entity vehicle ) callbackFunc )
{
	file.onRodeoStartingCallbacks.append( callbackFunc )
}


void function AddCallback_OnRodeoEnded( void functionref( entity rider, entity vehicle ) callbackFunc )
{
	file.onRodeoEndedCallbacks.append( callbackFunc )
}


//////////////////////////
//////////////////////////
//// Shared Callbacks ////
//////////////////////////
//////////////////////////
void function OnPlayerCreated( entity player )
{
	RodeoRiderState riderState
	riderState.rider = player

	file.riderStateMap[player] <- riderState

	#if SERVER
	#if RODEO
		Code_Rodeo_RiderDisallow( player )
	#endif

		AddEntityDestroyedCallback( player, OnPlayerDestroyed )
	#endif
}


void function OnPlayerDestroyed( entity player )
{
	if ( player in file.riderStateMap )
		delete file.riderStateMap[player]
}

bool function CodeCallback_CanPlayerRodeo( entity player )
{
	vector playerVelocity = player.GetVelocity();
	float playerSpeedSqr = LengthSqr( playerVelocity );
	if ( playerSpeedSqr > 1000.0 * 1000.0 )
	{
		float playerSpeed = sqrt( playerSpeedSqr );
		vector playerVelocityDir = playerVelocity / playerSpeed;
		if ( playerVelocityDir.z > 0.5 )
		{
			return false;
		}
	}

	return true
}

bool function CodeCallback_IsValidRodeoTarget( entity rider, entity vehicle )
{
	if ( !CanRiderRodeoTarget( rider, vehicle ) )
		return false

	RodeoVehicleState vehicleState = GetRodeoVehicleState( vehicle )

	int transitionIndex = vehicleState.flavor.getAttachTransition( rider, vehicle )
	//Assert( transitionIndex != RODEO_SENTINEL_TRANSITION_NONE )
	if ( transitionIndex == RODEO_SENTINEL_TRANSITION_NONE )
		return false

	if ( vehicleState.flavor.isValidRodeoTarget != null )
	{
		return vehicleState.flavor.isValidRodeoTarget( rider, vehicle )
	}
	else
	{
		if ( vehicle.GetScriptName() == "hoverbike_rodeo_proxy" )
			return rider.IsInputCommandHeld( IN_USE_LONG )

		// todo(dw): better IsValidRodeoTarget logic
		#if SERVER
			if ( RodeoUtil_GetVehicleRodeoStateEnt( vehicle ) != rider.p.PROTO_RequestedRodeoStateEnt )
				return false
		#else

			// todo(dw): rodeo request target finding in CodeCallback_IsValidRodeoTarget on client
			if ( !rider.IsInputCommandHeld( IN_USE_LONG ) )
				return false
		#endif
	}

	return true
}


var function CodeCallback_OnRodeoAttach( entity rider, entity vehicle )
{
	#if CLIENT
		Assert( rider == GetLocalViewPlayer() ) // todo(dw): remove this
	#endif

	//if ( !CheckRodeoDistance( rider, vehicle ) )
	//	return null

	RodeoVehicleState vehicleState = GetRodeoVehicleState( vehicle )
	//Assert( vehicleState != null )

	if ( vehicleState.flavor.isValidRodeoTarget != null )
	{
		Assert( vehicleState.flavor.isValidRodeoTarget( rider, vehicle ) )
	}

	int transitionIndex = vehicleState.flavor.getAttachTransition( rider, vehicle )
	//Assert( transitionIndex != RODEO_SENTINEL_TRANSITION_NONE )
	if ( transitionIndex == RODEO_SENTINEL_TRANSITION_NONE )
		return null

	RodeoTransitionFlavor transitionFlavor = vehicleState.flavor.transitionMap[transitionIndex]
	Assert( transitionFlavor.beginSpotIndex == RODEO_SENTINEL_BEGIN_SPOT_ATTACH )

	RodeoRiderState riderState = GetRodeoRiderState( rider )
	#if SERVER
		InitRiderTransition( riderState, vehicleState, transitionIndex, false )
	#endif

	return {
		attachment = transitionFlavor.attachment,
		firstPersonAnim = transitionFlavor.firstPersonAnim,
		thirdPersonAnim = transitionFlavor.thirdPersonAnim,
		rodeoSlot = transitionFlavor.endSpotIndex,
	}
}


void function RodeoInternal_OnVehicleRiderChanged( entity vehicleStateEnt, int spotIndex, entity oldRider, entity newRider )
{
	// This cannot be used to reliably detect the start and end of a rodeo on the client,
	// because there's no good way to tell the difference between those and a rider changing spots
	// Start:
	//		spot 0: null -> rider
	// Moving from spot 0 to spot 1:
	//		spot 0: rider -> null
	//		spot 1: null -> rider
	// Moving from spot 0 to spot 1:
	//		spot 0: null -> rider
	//		spot 1: rider -> null
	// End:
	//		spot 0: rider -> null
	// There's also cases where a transition reserves multiple spots and then releases them.
	// And detach transitions generally don't reserve any spots at all, which means that spots cannot be used to detect overall rodeo state at all.
	// Fortunately, we have ClientCodeCallback_TitanRodeoedUpdated, which is called not just for our local players but ALL players :)
}


void function CodeCallback_TitanRiderEntVarChanged( entity soul, int rodeoSlotIndex, entity oldRider, entity newRider )
{
	// strangely, this is available and called for ALL NPCs, not just titans
	//printt( "CodeCallback_TitanRiderEntVarChanged", soul, rodeoSlotIndex, oldRider, newRider )

	if ( oldRider == null && newRider == null )
	{
		return // weird case
	}
	if ( soul ==  null )
	{
		return // a very weird case
	}

	RodeoInternal_OnVehicleRiderChanged( soul, rodeoSlotIndex, oldRider, newRider )
}


//////////////////////////
//////////////////////////
//// Server Callbacks ////
//////////////////////////
//////////////////////////
#if SERVER
void function CodeCallback_StartRodeo( entity rider, entity vehicle )
{
	Assert( true )

	RodeoVehicleState vehicleState = GetRodeoVehicleState( vehicle )
	RodeoRiderState riderState     = GetRodeoRiderState( rider )
	Assert( vehicle.GetRodeoRider( riderState.currentSpotIndex ) == rider )

	riderState.vehicleStateEnt = vehicleState.stateEnt
	thread RiderRodeoThread( riderState, vehicleState )
}


void function CodeCallback_ForceEndRodeo( entity rider )
{
	Rodeo_TriggerRiderRodeoEnd( rider )
}
#endif


//////////////////////////
//////////////////////////
//// Client Callbacks ////
//////////////////////////
//////////////////////////
#if CLIENT
void function RodeoInternal_OnRiderVehicleRodeoedChanged( entity rider, entity vehicleStateEnt )
{
	RodeoRiderState riderState = GetRodeoRiderState( rider )

	if ( vehicleStateEnt != null )
	{
		// attaching
		//Assert( riderState.vehicleStateEnt == null ) // todo(dw): get ClientCodeCallback_TitanRodeoedUpdated fixed
		entity vehicle                 = RodeoUtil_GetVehicleEntFromStateEnt( vehicleStateEnt )
		RodeoVehicleState vehicleState = GetRodeoVehicleState( vehicle )

		riderState.vehicleStateEnt = vehicleStateEnt
		rider.Signal( "RodeoStarting" )

		if ( vehicleState.flavor.onRodeoStartingFunc != null )
		{
			vehicleState.flavor.onRodeoStartingFunc( rider, vehicle )
		}
		foreach( callbackFunc in file.onRodeoStartingCallbacks )
		{
			callbackFunc( rider, vehicle )
		}
	}
	else
	{
		// detaching
		//Assert( riderState.vehicleStateEnt != null ) // unfortunately, this isn't reliable

		entity vehicle = null
		if ( IsValid( riderState.vehicleStateEnt ) )
		{
			vehicle = RodeoUtil_GetVehicleEntFromStateEnt( riderState.vehicleStateEnt )

			RodeoVehicleState vehicleState = GetRodeoVehicleState( vehicle ) // todo(dw): this inability to get the vehicle's flavor from an invalid ent is really bad, it may lead to inconsistent state
			if ( vehicleState.flavor.onRodeoFinishingFunc != null )
			{
				vehicleState.flavor.onRodeoFinishingFunc( rider, vehicle )
			}
		}

		foreach( callbackFunc in file.onRodeoEndedCallbacks )
		{
			callbackFunc( riderState.rider, vehicle )
		}

		riderState.vehicleStateEnt = null
		riderState.prevRodeoTime = Time()
		rider.Signal( "RodeoEnded" )
	}

	//if ( IsValid( vehicle ) )
	//{
	//	player.SetRodeoLookHeight()
	//	player.SetRodeoLookDistance()
	//	player.SetRodeoLookRight()
	//	player.Rodeo_StartCameraSmoothing( 0.25 )
	//}
	//else
	//{
	//	player.Rodeo_StopCameraSmoothing( 0.25 )
	//}
}

void function ClientCodeCallback_TitanRodeoedUpdated( entity player )
{
	printt( "ClientCodeCallback_TitanRodeoedUpdated", player, player.GetTitanSoulBeingRodeoed() )
	RodeoInternal_OnRiderVehicleRodeoedChanged( player, player.GetTitanSoulBeingRodeoed() )
}

void function ClientCodeCallback_RodeoHitTimeChanged( entity soul )
{
	//
}
#endif


//////////////////////////
//////////////////////////
//////////////////////////
//////////////////////////
//////////////////////////
entity function GetRiderCurrentVehicle( entity rider )
{
	entity vehicleStateEnt = rider.GetTitanSoulBeingRodeoed()
	if ( !IsValid( vehicleStateEnt ) )
		return null

	return RodeoUtil_GetVehicleEntFromStateEnt( vehicleStateEnt )
}

#if SERVER
void function SetRiderCurrentVehicle( entity rider, entity vehicle )
{
	if ( vehicle == null )
	{
		rider.SetTitanSoulBeingRodeoed( null )
		return
	}

	entity vehicleStateEnt = RodeoUtil_GetVehicleRodeoStateEnt( vehicle )

	// this may be a bad idea as the stateEnt for non-titans is not a soul
	rider.SetTitanSoulBeingRodeoed( vehicleStateEnt )
}
#endif

entity function GetRodeoRider( entity vehicle, int spotIndex )
{
	if ( vehicle.IsPlayer() || vehicle.IsNPC() )
	{
		return vehicle.GetRodeoRider( spotIndex )
	}

	Assert( false, "NYI - vehicle is not CBaseCombatCharacter" )
	unreachable
}

#if SERVER
void function SetRodeoRider( entity vehicle, int spotIndex, entity rider )
{
	if ( vehicle.IsPlayer() || vehicle.IsNPC() )
	{
		vehicle.SetRodeoRider( spotIndex, rider )
		return
	}

	Assert( false, "NYI - vehicle is not CBaseCombatCharacter" )
}
#endif

bool function CanRiderRodeoTarget( entity rider, entity vehicle )
//, bool skipDistanceCheck = false )
{
	// does not consider spot availability

	if ( IsPlayerDisembarking( rider ) )
		return false

	if ( rider.ContextAction_IsActive() )
		return false

	if ( rider.GetWeaponDisableFlags() == WEAPON_DISABLE_FLAGS_ALL )
		return false

	// if we are both phased, cool.  if we are both not phased, also cool
	if ( rider.IsPhaseShifted() != vehicle.IsPhaseShifted() )
		return false

	#if SERVER
		// todo(dw): do this on client too
		RodeoRiderState riderState = GetRodeoRiderState( rider )
		if ( riderState.timePressedUseToDetach != null )
		{
			if ( Time() < expect float( riderState.timePressedUseToDetach ) + 2.1 )
				return false
		}
	#endif

	if ( vehicle.GetScriptName() == "hoverbike_rodeo_proxy" )
		return true // todo(dw): !!!

	bool doDefaultChecks = true
	foreach( callbackFunc in file.canRiderRodeoVehicleCallbacks )
	{
		int result = callbackFunc( rider, vehicle )

		if ( result == eCanRiderRodeoVehicleResult.DISALLOW )
			return false


		if ( result == eCanRiderRodeoVehicleResult.ALLOW )
			doDefaultChecks = false
	}

	if ( doDefaultChecks )
	{
		if ( rider.GetTeam() != vehicle.GetTeam() )
			return false
	}

	//float boundingFrac = 0.8
	//vector vehicleTopCenterSpot    = vehicle.GetOrigin() + <0, 0, vehicle.GetBoundingMins().z>
	//vector vehicleBottomCenterSpot = vehicle.GetOrigin() + <0, 0, vehicle.GetBoundingMaxs().z>
	//vector vehicleConsiderationPos = GetClosestPointOnLineSegment( vehicleTopCenterSpot, vehicleBottomCenterSpot, rider.GetWorldSpaceCenter() )
	//TraceResults result = TraceHull(
	//	rider.GetOrigin(), rider.GetOrigin() , boundingFrac * rider.GetBoundingMins(), boundingFrac * rider.GetBoundingMaxs(),
	//	[ rider, vehicle ], TRACE_MASK_PLAYERSOLID, TRACE_COLLISION_GROUP_PLAYER
	//)

	//return vehicle.GetIsValidRodeoTarget()
	return true
}


RodeoVehicleState function GetRodeoVehicleState( entity vehicle )
{
	Assert( IsValid( vehicle ) )
	entity vehicleStateEnt = RodeoUtil_GetVehicleRodeoStateEnt( vehicle )
	Assert( IsValid( vehicleStateEnt ) )
	Assert( vehicleStateEnt in file.vehicleStateMap )
	return file.vehicleStateMap[vehicleStateEnt]
	//return vehicleStateEnt in file.vehicleStateMap ? file.vehicleStateMap[vehicleStateEnt] : null
}


RodeoRiderState function GetRodeoRiderState( entity rider )
{
	Assert( rider in file.riderStateMap )
	return file.riderStateMap[rider]
}


RodeoSpotFlavor function RodeoVehicleFlavor_AddSpot( RodeoVehicleFlavor vehicleFlavor, int index )
{
	Assert( index >= 0 )
	Assert( !(index in vehicleFlavor.spotMap) )

	RodeoSpotFlavor spotFlavor
	spotFlavor.index = index
	vehicleFlavor.spotMap[index] <- spotFlavor

	return spotFlavor
}


RodeoTransitionFlavor function RodeoVehicleFlavor_AddTransition( RodeoVehicleFlavor vehicleFlavor, int index, int beginSpotIndex, int endSpotIndex )
{
	Assert( index >= 0 )
	Assert( !(index in vehicleFlavor.transitionMap) )

	RodeoTransitionFlavor transitionFlavor
	transitionFlavor.index = index
	Assert( beginSpotIndex == RODEO_SENTINEL_BEGIN_SPOT_ATTACH || beginSpotIndex in vehicleFlavor.spotMap )
	transitionFlavor.beginSpotIndex = beginSpotIndex
	Assert( endSpotIndex == RODEO_SENTINEL_END_SPOT_DETACH || endSpotIndex in vehicleFlavor.spotMap )
	transitionFlavor.endSpotIndex = endSpotIndex
	vehicleFlavor.transitionMap[index] <- transitionFlavor

	return transitionFlavor
}


void function OnRodeoVehicleStateEntDestroyed( entity vehicle )
{
	entity vehicleStateEnt = RodeoUtil_GetVehicleRodeoStateEnt( vehicle )
	// do rodeo-end callbacks
	delete file.vehicleStateMap[ vehicleStateEnt ]
}

#if SERVER
void function RiderRodeoThread( RodeoRiderState riderState, RodeoVehicleState vehicleState )
{
	entity rider = riderState.rider
	Assert( IsValid( rider ) )
	Assert( rider.GetParent() == null )
	Assert( !rider.IsTitan() )

	Assert( IsValid( vehicleState.stateEnt ) )
	Assert( riderState.vehicleStateEnt == vehicleState.stateEnt )
	entity vehicle = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt )
	Assert( IsValid( vehicle ) )

	riderState.playerWasEjecting = rider.p.pilotEjecting // used to detect eject -> rodeo

	OnThreadEnd(
		function () : ( riderState, vehicleState )
		{
			entity rider = riderState.rider
			rider.Signal( "RodeoEnding" )
			if ( IsValid( rider ) )
			{
				//rider.DisableWorldSpacePlayerEyeAngles() // stop player's view from being dependant on parent
				ClearPlayerAnimViewEntity( rider, 0.4 )
				rider.ClearParent()
				rider.Anim_Stop()

				//rider.SetNameVisibleToFriendly( true )
				//rider.SetNameVisibleToEnemy( true )
				rider.UnforceStand()
				rider.SetOneHandedWeaponUsageOff()
				SetRiderCurrentVehicle( rider, null )

				if ( riderState.lastTransitionCockpitSoundPlayed != "" )
				{
					StopSoundOnEntity( rider, riderState.lastTransitionCockpitSoundPlayed )
					riderState.lastTransitionCockpitSoundPlayed = ""
				}
				if ( riderState.lastTransitionWorldSoundPlayed != "" )
				{
					StopSoundOnEntity( rider, riderState.lastTransitionWorldSoundPlayed )
					riderState.lastTransitionWorldSoundPlayed = ""
				}

				if ( IsAlive( rider ) )
				{
#if RODEO
					Assert( Code_Rodeo_IsAttached( rider ) )
					Code_Rodeo_Detach( rider )
#endif
				}

				rider.JumpedOffRodeo()

				if ( riderState.areWeaponsDisabled )
				{
					DeployAndEnableWeapons( rider )
					riderState.areWeaponsDisabled = false
				}
			}

			//vehicle.SetRodeoRider( riderState.currentSpotIndex, null ) // code does this for us
			riderState.currentSpotIndex = RODEO_SENTINEL_INVALID_SPOT
			riderState.currentTransitionIndex = RODEO_SENTINEL_TRANSITION_NONE
			riderState.vehicleStateEnt = null

			entity vehicle
			if ( IsValid( vehicleState.stateEnt ) )
			{
				vehicle = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt ) // re-get vehicle because it may have changed
			}
			if ( IsValid( rider ) )
			{
				PutEntityInSafeSpot(
					rider, IsValid( vehicle ) ? vehicle : null, null,
					rider.GetOrigin(), rider.GetOrigin()
				)
				// todo(dw): adjust player position and velocity?
			}
			if ( IsValid( vehicle ) )
			{
				vehicle.Signal( "RodeoRiderDetached" )
			}
			riderState.prevRodeoTime = Time()
			rider.Signal( "RodeoEnded" ) // todo(dw): make sure nowhere else triggers this signal
			if ( vehicleState.flavor.onRodeoFinishingFunc != null )
			{
				vehicleState.flavor.onRodeoFinishingFunc( riderState.rider, vehicle )
			}
			foreach( callbackFunc in file.onRodeoEndedCallbacks )
			{
				callbackFunc( riderState.rider, vehicle )
			}
		}
	)

	rider.EndSignal( "OnDeath" )
	rider.EndSignal( "RodeoTriggerInstantDetach" )
	vehicleState.stateEnt.EndSignal( "OnDeath" )
	vehicleState.stateEnt.EndSignal( "OnTitanDeath" ) // todo(dw): find a way to remove this special case?
	vehicleState.stateEnt.EndSignal( "OnDestroy" ) // OnDeath works in most cases, except in the state ent is a titan soul
	vehicleState.stateEnt.EndSignal( "TitanEjectionStarted" )

	thread WatchForPlayerJumpingOffRodeo( rider, vehicleState.flavor.jumpOffKey )

	rider.Lunge_ClearTarget()
	//rider.SetNameVisibleToFriendly( false ) // hide name of the pilot while he is rodeoing
	//rider.SetNameVisibleToEnemy( false )
	rider.ForceStand()
	rider.SetOneHandedWeaponUsageOn()
	SetRiderCurrentVehicle( rider, vehicle )

	rider.TouchGround() // allow double jump

	//if ( soul.GetShieldHealth() > 0.0 )
	//{
	//	GiveFriendlyRodeoPlayerProtection( rodeoTitan )
	//}

	rider.Signal( "RodeoStarting" )
	vehicle.Signal( "RodeoRiderAttached" )

	if ( vehicleState.flavor.onRodeoStartingFunc != null )
	{
		vehicleState.flavor.onRodeoStartingFunc( rider, vehicle )
	}

	foreach( callbackFunc in file.onRodeoStartingCallbacks )
	{
		callbackFunc( rider, vehicle )
	}


	// InitRiderTransition should have already been called by OnRodeoAttach
	thread DoRiderTransition( riderState, vehicleState )

	rider.WaitSignal( "RodeoTriggerGracefulDetach" )

	if ( vehicleState.flavor.jumpOffKey == IN_USE )
	{
		riderState.timePressedUseToDetach = Time()
	}

	if ( riderState.currentTransitionIndex != RODEO_SENTINEL_TRANSITION_NONE )
	{
		return // if the rider is in the middle of a transition, we can't gracefully detach
	}

	// otherwise, play a detach transition

	foreach ( transitionIndex, transitionFlavor in vehicleState.flavor.transitionMap )
	{
		// find a detach transition for the rider's current spot
		if ( transitionFlavor.beginSpotIndex == riderState.currentSpotIndex && transitionFlavor.endSpotIndex == RODEO_SENTINEL_END_SPOT_DETACH )
		{
			// play it
			InitRiderTransition( riderState, vehicleState, transitionIndex )
			thread DoRiderTransition( riderState, vehicleState )
			WaitForever() // the transition will trigger RodeoTriggerInstantDetach
			break
		}
	}
	// if no detach transition was found, immediate detach logic will run on return

	// let's also let the player actually "jump" off the titan
	thread GivePlayerVelocityAfterRodeo( riderState )

	// and player a generic "jumping off" sound
	vehicle = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt )
	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Rodeo_Jump_Off_Interior", "Rodeo_Jump_Off", rider, vehicle )
}

void function InitRiderTransition( RodeoRiderState riderState, RodeoVehicleState vehicleState, int transitionIndex, bool shouldSetEndSlotOnVehicle = true )
{
	Assert( riderState.currentTransitionIndex == RODEO_SENTINEL_TRANSITION_NONE )

	entity vehicle                         = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt )
	RodeoTransitionFlavor transitionFlavor = vehicleState.flavor.transitionMap[transitionIndex]

	riderState.currentTransitionIndex = transitionIndex

	if ( transitionFlavor.beginSpotIndex == RODEO_SENTINEL_BEGIN_SPOT_ATTACH )
	{
		Assert( riderState.currentSpotIndex == RODEO_SENTINEL_INVALID_SPOT )
	}
	else
	{
		Assert( riderState.currentSpotIndex == transitionFlavor.beginSpotIndex )
		Assert( vehicle.GetRodeoRider( transitionFlavor.beginSpotIndex ) == riderState.rider )
		// If we unreserve the begin spot right away, another player can take the spot (if we're not returning to it), which seems fluid and nice
		vehicle.SetRodeoRider( transitionFlavor.beginSpotIndex, null )
	}

	foreach ( int transientSpotIndex in transitionFlavor.transientSpotIndexList )
	{
		Assert( vehicle.GetRodeoRider( transientSpotIndex ) == null )
		vehicle.SetRodeoRider( transientSpotIndex, riderState.rider )
	}

	if ( transitionFlavor.endSpotIndex == RODEO_SENTINEL_END_SPOT_DETACH )
	{
		// detaching
		riderState.currentSpotIndex = RODEO_SENTINEL_INVALID_SPOT
	}
	else
	{
		// riding
		riderState.currentSpotIndex = transitionFlavor.endSpotIndex
		Assert( vehicle.GetRodeoRider( transitionFlavor.endSpotIndex ) == null )
		if ( shouldSetEndSlotOnVehicle )
			// if we do this before OnRodeoAttach returns, then code thinks there's already a rider in the spot and doesn't continue
			vehicle.SetRodeoRider( transitionFlavor.endSpotIndex, riderState.rider )
	}
}

void function CleanupRiderTransition( RodeoRiderState riderState, RodeoVehicleState vehicleState )
{
	Assert( riderState.currentTransitionIndex != RODEO_SENTINEL_TRANSITION_NONE )

	entity vehicle                         = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt )
	RodeoTransitionFlavor transitionFlavor = vehicleState.flavor.transitionMap[riderState.currentTransitionIndex]

	riderState.currentTransitionIndex = RODEO_SENTINEL_TRANSITION_NONE

	foreach ( int transientSpotIndex in transitionFlavor.transientSpotIndexList )
	{
		Assert( vehicle.GetRodeoRider( transientSpotIndex ) == riderState.rider )
		vehicle.SetRodeoRider( transientSpotIndex, null )
	}

	if ( transitionFlavor.endSpotIndex != RODEO_SENTINEL_END_SPOT_DETACH )
	{
		// riding
		Assert( vehicle.GetRodeoRider( transitionFlavor.endSpotIndex ) == riderState.rider )
	}
}

void function DoRiderTransition( RodeoRiderState riderState, RodeoVehicleState vehicleState )
{
	// Precondition: InitRiderTransition has been called before this function runs
	Assert( riderState.currentTransitionIndex != RODEO_SENTINEL_TRANSITION_NONE )

	vehicleState.stateEnt.EndSignal( "OnDeath" )
	entity rider = riderState.rider
	rider.EndSignal( "OnDeath" )
	rider.EndSignal( "RodeoEnding" )
	entity vehicle = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt )

	// at this stage, the rider has already reserved the neccessary spots

	rider.Signal( "RodeoTransitionStarting" )

	if ( !riderState.areWeaponsDisabled )
	{
		HolsterAndDisableWeapons( rider )
		riderState.areWeaponsDisabled = true // disable weapons for all transitions
	}

	RodeoTransitionFlavor transitionFlavor = vehicleState.flavor.transitionMap[riderState.currentTransitionIndex]

	if ( vehicleState.flavor.onRodeoTransitionStartingFunc != null )
	{
		vehicleState.flavor.onRodeoTransitionStartingFunc( rider, vehicle, transitionFlavor.beginSpotIndex, transitionFlavor.endSpotIndex, riderState.currentTransitionIndex )
	}

	if ( transitionFlavor.doBasicAnim )
	{
		if ( transitionFlavor.execFunc != null )
		{
			// if the transition has a custom function, execute it
			thread transitionFlavor.execFunc( rider, vehicleState.stateEnt )
		}

		waitthread RodeoInternal_DoTransitionBasicAnim( riderState, transitionFlavor )
	}
	else
	{
		Assert( transitionFlavor.execFunc != null )
		waitthread transitionFlavor.execFunc( rider, vehicleState.stateEnt )
	}
	CleanupRiderTransition( riderState, vehicleState )

	vehicle = RodeoUtil_GetVehicleEntFromStateEnt( vehicleState.stateEnt ) // re-get vehicle because it may have changed

	Assert( riderState.areWeaponsDisabled )

	if ( transitionFlavor.endSpotIndex != RODEO_SENTINEL_END_SPOT_DETACH )
	{
		// if we're riding on a spot, play the idle animation
		RodeoSpotFlavor spotFlavor = vehicleState.flavor.spotMap[transitionFlavor.endSpotIndex]

		Assert( !spotFlavor.idleIsError, "Rider ended on a spot that should never be idled on" )

		FirstPersonSequenceStruct sequence
		sequence.attachment = spotFlavor.attachPoint
		sequence.thirdPersonAnimIdle = spotFlavor.thirdPersonIdleAnim
		sequence.firstPersonAnimIdle = spotFlavor.firstPersonIdleAnim
		sequence.useAnimatedRefAttachment = true
		sequence.prediction = true
		thread FirstPersonSequence( sequence, rider, vehicle )

		if ( !spotFlavor.disableWeapons )
		{
			DeployAndEnableWeapons( rider )
			riderState.areWeaponsDisabled = false
		}
	}
	else
	{
		DeployAndEnableWeapons( rider )
		riderState.areWeaponsDisabled = false
	}

	//rider.PlayerCone_FromAnim()
	rider.GetFirstPersonProxy().HideFirstPersonProxy()
	//rider.PlayerCone_SetMinYaw( -179 )
	//rider.PlayerCone_SetMaxYaw( 181 )
	//rider.PlayerCone_SetMinPitch( -60 )
	//rider.PlayerCone_SetMaxPitch( 60 )
	//rider.PlayerCone_SetMinYaw( -105 )
	//rider.PlayerCone_SetMaxYaw( 105 )
	//rider.PlayerCone_SetMinPitch( -90 )
	//rider.PlayerCone_SetMaxPitch( 90 )
	//rider.PlayerCone_FromAnim()
	rider.PlayerCone_Disable() // let the player look around
	// script "(function(p){p.PlayerCone_SetMinYaw(-105);p.PlayerCone_SetMaxYaw(105);p.PlayerCone_SetMinPitch(-90);p.PlayerCone_SetMaxPitch(50)})(gp()[0])"

	if ( transitionFlavor.beginSpotIndex == RODEO_SENTINEL_BEGIN_SPOT_ATTACH )
	{
#if RODEO
		Code_Rodeo_OnFinishClimbOnAnimation( rider ) // if we've just attached, let code know we've finished the climb animation
#endif
		rider.Signal( "RodeoClimbComplete" )
	}
	rider.Signal( "RodeoTransitionEnded" )

	if ( transitionFlavor.endSpotIndex == RODEO_SENTINEL_END_SPOT_DETACH )
	{
		// we're detaching
		rider.Signal( "RodeoTriggerInstantDetach" )
	}
	else
	{
		// we're riding
		rider.DisableWorldSpacePlayerEyeAngles() // make player's view dependant on parent

		if ( vehicleState.flavor.onRodeoRiderIdlesInSpotFunc != null )
		{
			vehicleState.flavor.onRodeoRiderIdlesInSpotFunc( rider, vehicle, transitionFlavor.endSpotIndex )
		}
	}
}

void function RodeoInternal_DoTransitionBasicAnim( RodeoRiderState riderState, RodeoTransitionFlavor transitionFlavor )
{
	riderState.vehicleStateEnt.EndSignal( "OnDeath" )
	riderState.rider.EndSignal( "OnDeath" )
	riderState.rider.EndSignal( "RodeoEnding" )
	entity vehicle = RodeoUtil_GetVehicleEntFromStateEnt( riderState.vehicleStateEnt )

	RodeoInternal_DoTransitionBasicSounds( riderState, transitionFlavor )

	FirstPersonSequenceStruct sequence
	sequence.attachment = expect string( transitionFlavor.attachment )
	sequence.thirdPersonAnim = expect string( transitionFlavor.thirdPersonAnim )
	sequence.firstPersonAnim = expect string( transitionFlavor.firstPersonAnim )

	sequence.blendTime = 0.6 // todo(dw): check this and also make attaching based on velocity and direction again

	//float time = riderState.rider.GetSequenceDuration( sequence.thirdPersonAnim )
	//riderState.rider.Anim_IgnoreParentRotation( !transitionFlavor.useAttachAngles )

	waitthread FirstPersonSequence( sequence, riderState.rider, vehicle )
	//wait time
}

void function RodeoInternal_DoTransitionBasicSounds( RodeoRiderState riderState, RodeoTransitionFlavor transitionFlavor )
{
	entity vehicle = RodeoUtil_GetVehicleEntFromStateEnt( riderState.vehicleStateEnt )

	if ( transitionFlavor.cockpitSound != null )
		riderState.lastTransitionCockpitSoundPlayed = expect string( transitionFlavor.cockpitSound )

	if ( transitionFlavor.worldSound != null )
		riderState.lastTransitionWorldSoundPlayed = expect string( transitionFlavor.worldSound )

	if ( transitionFlavor.cockpitSound != null && transitionFlavor.worldSound != null )
	{
		EmitDifferentSoundsOnEntityForPlayerAndWorld(
			riderState.lastTransitionCockpitSoundPlayed, riderState.lastTransitionWorldSoundPlayed,
			riderState.rider, vehicle
		)
	}
	else if ( transitionFlavor.cockpitSound != null )
	{
		EmitSoundOnEntityOnlyToPlayer( vehicle, vehicle, riderState.lastTransitionCockpitSoundPlayed )
	}
	else if ( transitionFlavor.worldSound != null )
	{
		EmitSoundOnEntity( vehicle, riderState.lastTransitionWorldSoundPlayed )
	}
}

void function GivePlayerVelocityAfterRodeo( RodeoRiderState riderState )
{
	entity rider = riderState.rider
	rider.EndSignal( "OnDeath" )

	entity vehicle = RodeoUtil_GetVehicleEntFromStateEnt( riderState.vehicleStateEnt )
	rider.IgnoreEntityForMovementUntilNotTouching( vehicle )

	rider.WaitSignal( "RodeoEnded" )

	vector velocityAdjustmentDir = RotateVector( <rider.GetInputAxisForward(), rider.GetInputAxisRight(), 0>, rider.EyeAngles() )
	velocityAdjustmentDir.z = 1.0
	velocityAdjustmentDir = Normalize( velocityAdjustmentDir )

	rider.SetVelocity( rider.GetVelocity() + 400.0 * velocityAdjustmentDir )
}


void function OnPlayerPressedDetachKey( entity player )
{
	Rodeo_TriggerRiderRodeoEnd( player )
	//thread DoPlayerJumpsOffRodeo( player )
}

void function WatchForPlayerJumpingOffRodeo( entity player, int key )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "RodeoEnded" )

	wait 0.6 // debounce so you dont accihop

	AddButtonPressedPlayerInputCallback( player, key, OnPlayerPressedDetachKey )

	OnThreadEnd( function() : ( player, key ) {
		RemoveButtonPressedPlayerInputCallback( player, key, OnPlayerPressedDetachKey )
	} )

	WaitForever()
}

//void function DoPlayerJumpsOffRodeo( player )
//{
//	Rodeo_TriggerRiderRodeoEnd( player )
//
//	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Rodeo_Jump_Off_Interior", "Rodeo_Jump_Off", player, rodeoTarget )
//
//	player.WaitSignal( "RodeoEnded" )
//
//}
#endif


///////////////////////
///////////////////////
//// Rodeo Request ////
///////////////////////
///////////////////////
entity function PROTO_FindRodeoRequestTarget( entity player )
{
	float velFrac    = GraphCapped( Length( player.GetVelocity() ), 175.0, 400.0, 0.0, 1.0 )
	float coneHeight = GraphCapped( velFrac, 0.0, 1.0, 450.0, 450.0 )
	float coneAngle  = GraphCapped( velFrac, 0.0, 1.0, 15.0, 22.0 )
	if ( coneHeight * coneAngle > 10000.0 )
	{
		Warning( "Rodeo request target cone too large (" + coneHeight + ", " + coneAngle + ")" )
		coneHeight = 9999.0 / coneAngle
	}

	array<VisibleEntityInCone> potentialEntities = FindVisibleEntitiesInCone(
		player.EyePosition(), player.GetViewForward(), coneHeight, coneAngle,
		[player], TRACE_MASK_SHOT, VIS_CONE_ENTS_TEST_HITBOXES | VIS_CONE_ENTS_IGNORE_VORTEX, player
	)
	entity targetVehicle                         = null
	foreach( VisibleEntityInCone potentialEntity in potentialEntities )
	{
		if ( potentialEntity.ent.GetScriptName() != "hoverbike_rodeo_proxy" )
		{
			if ( !potentialEntity.ent.IsTitan() )
				continue

			if ( !potentialEntity.ent.IsPlayer() )
				// survival specific logic
				continue
		}

		if ( !CanRiderRodeoTarget( player, potentialEntity.ent ) )
			continue

		// todo(dw): check rodeo request target is suitable for rodeo
		// todo(dw): prioritise rodeo request targets by distance and dot

		targetVehicle = potentialEntity.ent
		break
	}
	return targetVehicle
}

#if CLIENT
void function OnPlayerLifestateChanged( entity player, int oldLifeState, int newLifeState )
{
	if ( player != GetLocalViewPlayer() )
		return

	if ( !file.PROTO_IsRodeoEvenUsed )
		return

	if ( oldLifeState != LIFE_ALIVE && newLifeState == LIFE_ALIVE )
	{
		thread PROTO_OfferRodeoRequestPrompt( player )
	}
}

void function PROTO_OfferRodeoRequestPrompt( entity player )
{
	player.EndSignal( "OnDeath" )

	//OnThreadEnd( function() : ( player ) {
	//	if ( IsValid( player ) )
	//		Code_Rodeo_RiderDisallow( player )
	//} )

	bool isRequestingPromptShown = false
	bool isUsePromptShown        = false
	while( true )
	{
		wait 0.29

		//if ( !Code_Rodeo_IsAllowed( player ) )
		//	continue

		if ( !RodeoState_IsRiderAllowedToRodeo( player ) )
			return

		bool isRodeoing = RodeoState_GetIsPlayerRodeoing( player )
		bool isTitan    = player.IsTitan()

		entity targetVehicle            = PROTO_FindRodeoRequestTarget( player )
		bool shouldShowRequestingPrompt = (!isRodeoing && !isTitan && targetVehicle != null && player.IsInputCommandHeld( IN_USE ))
		bool shouldShowUsePrompt        = (!isRodeoing && !isTitan && targetVehicle != null && !shouldShowRequestingPrompt)

		if ( shouldShowRequestingPrompt )
		{
			//Code_Rodeo_RiderAllow( player ) // needs prediction

			if ( !isRequestingPromptShown )
			{
				if ( targetVehicle.IsTitan() )
				{
					AddPlayerHint( 9999.0, 0.1, $"rui/hud/common/rodeo_icon_friendly", "  Rodeoing friendly titan..." ) // todo(dw): !
				}
				isRequestingPromptShown = true
			}
		}
		else if ( isRequestingPromptShown )
		{
			//Code_Rodeo_RiderDisallow( player ) // needs prediction

			HidePlayerHint( "  Rodeoing friendly titan..." ) // todo(dw): !
			isRequestingPromptShown = false
		}

		//printt( "shouldShowUsePrompt", targetVehicle, shouldShowUsePrompt )
		//printt( "isUsePromptShown", isUsePromptShown )

		if ( shouldShowUsePrompt )
		{
			if ( !isUsePromptShown )
			{
				if ( targetVehicle.IsTitan() )
				{
					AddPlayerHint( 9999.0, 0.2, $"rui/hud/common/rodeo_icon_friendly", "  %&use_long% to rodeo friendly titan" ) // todo(dw): !
				}
				else
				{
					AddPlayerHint( 9999.0, 0.2, $"rui/hud/common/rodeo_icon_friendly", "  %&use_long% to ride" ) // todo(dw): !
				}
				isUsePromptShown = true
			}
		}
		else if ( isUsePromptShown )
		{
			//printt( "HIDING", shouldShowUsePrompt, isUsePromptShown )
			HidePlayerHint( "  %&use_long% to rodeo friendly titan" ) // todo(dw): !
			HidePlayerHint( "  %&use_long% to ride" ) // todo(dw): !
			isUsePromptShown = false
		}

		if ( isRodeoing )
			player.WaitSignal( "RodeoEnded" )

		//if ( isTitan )
		//	player.WaitSignal( "???" ) // todo(dw): find an appropriate client signal for local player becomes pilot

		wait 0.29
	}
}
#endif
#if SERVER
void function OnPlayerRespawned( entity player )
{
#if RODEO
	Code_Rodeo_RiderDisallow( player )
#endif

	//thread PROTO_WatchForPlayerRequestingRodeo( player )
}
void function OnPlayerPressedRequestRodeoKey( entity player )
{
	if ( player.ContextAction_IsBusy() )
		return

	//thread PROTO_MovePlayerTowardRodeoVehicle( player )
}
void function OnPlayerReleasedRequestRodeoKey( entity player )
{
	player.Signal( "PlayerStopsRequestingRodeo" )
}
void function PROTO_WatchForPlayerRequestingRodeo( entity player )
{
	player.EndSignal( "OnDeath" )

	AddButtonPressedPlayerInputCallback( player, IN_USE_LONG, OnPlayerPressedRequestRodeoKey )
	AddButtonReleasedPlayerInputCallback( player, IN_USE_LONG, OnPlayerReleasedRequestRodeoKey )

	OnThreadEnd( function() : ( player ) {
		RemoveButtonPressedPlayerInputCallback( player, IN_USE_LONG, OnPlayerPressedRequestRodeoKey )
		RemoveButtonReleasedPlayerInputCallback( player, IN_USE_LONG, OnPlayerReleasedRequestRodeoKey )
	} )

	WaitForever()
}
void function PROTO_MovePlayerTowardRodeoVehicle( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "PlayerStopsRequestingRodeo" )
	player.EndSignal( "RodeoStarting" )

	OnThreadEnd( function() : ( player ) {
		if ( IsValid( player ) )
		{
			player.p.PROTO_RequestedRodeoStateEnt = null
			player.SetGroundFrictionScale( 1.0 )
			player.SetWallrunFrictionScale( 1.0 )
			RunClientCommandOnPlayer( player, "-jump" )
#if RODEO
			Code_Rodeo_RiderDisallow( player )
#endif
		}
	} )

	RodeoRiderState riderState = GetRodeoRiderState( player )

	while( true )
	{
		WaitFrame()

		if ( riderState.disallowRodeoStackCount > 0 )
		{
#if RODEO
			Code_Rodeo_RiderDisallow( player )
#endif
			continue
		}
#if RODEO
		Code_Rodeo_RiderAllow( player )
#endif

		entity targetVehicle = PROTO_FindRodeoRequestTarget( player )
		if ( targetVehicle != null )
		{
			entity targetVehicleStateEnt = RodeoUtil_GetVehicleRodeoStateEnt( targetVehicle )
			float startTime              = Time()
			while( true )
			{
				targetVehicle = RodeoUtil_GetVehicleEntFromStateEnt( targetVehicleStateEnt )
				if ( !CanRiderRodeoTarget( player, targetVehicle ) )
					break

				player.ClearTraverse()
				player.SetGroundFrictionScale( 0.0 )
				player.SetWallrunFrictionScale( 0.0 )

				vector playerPos               = player.EyePosition()
				vector vehicleTopCenterSpot    = targetVehicle.GetOrigin() + <0, 0, targetVehicle.GetBoundingMins().z>
				vector vehicleBottomCenterSpot = targetVehicle.GetOrigin() + <0, 0, targetVehicle.GetBoundingMaxs().z>
				vector vehicleConsiderationPos = GetClosestPointOnLineSegment( vehicleTopCenterSpot, vehicleBottomCenterSpot, playerPos )
				vector playerToVehicleDir      = Normalize( vehicleConsiderationPos - playerPos )
				vector playerViewDir           = player.GetViewForward()
				float playerToVehicleDist      = Length( vehicleConsiderationPos - playerPos )
				bool isClose                   = (playerToVehicleDist < 200.0)
				float extraUpVel               = (isClose ? 200.0 : 0.0)

				if ( DotProduct( playerViewDir, playerToVehicleDir ) < 0.8 )
					break

				if ( playerToVehicleDist > 410.0 )
					// todo(dw): remove magic numbers in rodeo requesting
					break

				float speed = max( 530.0 * Clamp( (Time() - startTime) / 1.2, 0.0, 1.0 ), Length( player.GetVelocity() ) )
				player.SetVelocity( speed * playerToVehicleDir ) //+ <0, 0, extraUpVel>
				// todo(dw): rodeo-requesting should make the player auto-sprint toward the titan instead of "floating"

				if ( isClose )
					RunClientCommandOnPlayer( player, "+jump" )

				player.p.PROTO_RequestedRodeoStateEnt = targetVehicleStateEnt

				WaitFrame()
			}
		}
	}
}
#endif


